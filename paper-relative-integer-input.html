<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../paper-styles/color.html">
<link rel="import" href="../polymer/polymer.html">

<!--
`paper-relative-integer-input`

@demo demo
-->

<dom-module id="paper-relative-integer-input">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }
      #input {
        text-align: center;
        --paper-input-container-input: {
          -moz-appearance: textfield;
          appearance: textfield;
        };
        --paper-input-container-input-webkit-spinner: {
          -webkit-appearance: none;
          appearance: none;
          margin: 0;
        };
        @apply --paper-relative-integer-input-paper-input;
      }
      .spinner {
        margin: 0;
        min-width: auto;
        --paper-button-disabled: {
          background: transparent;
        };
        @apply --paper-relative-integer-input-spinner;
      }
      .spinner:hover {
        background: rgba(0, 0, 0, 0.1);
        @apply --paper-relative-integer-input-spinner-hover;
      }
    </style>

    <paper-input
        id="input"
        type="number"
        value="{{value}}"
        label="[[label]]"
        no-label-float="[[noLabelFloat]]"
        always-label-float="[[alwaysLabelFloat]]"
        allowed-pattern="[0-9]"
        aria-labelledby$="[[_ariaLabelledBy]]"
        aria-describedby$="[[_ariaDescribedBy]]"
        disabled$="[[disabled]]"
        title$="[[title]]"
        invalid="{{invalid}}"
        validator="[[validator]]"
        required$="[[required]]"
        autofocus$="[[autofocus]]"
        min$="[[_min]]"
        max$="[[_max]]"
        step$="[[_step]]"
        name$="[[name]]"
        placeholder$="[[placeholder]]"
        readonly$="[[readonly]]"
        tabindex$="[[tabIndex]]"
        invalid="{{invalid}}"
        error-message="{{errorMessage}}"
        required="{{required}}"
        auto-validate="[[autoValidate]]"
        validator="[[validator]]">

      <paper-button
          tabindex="-1"
          class="spinner"
          slot="prefix"
          prefix
          on-tap="stepDown"
          disabled="[[_computeStepDownButtonDisabled(value, _min, disabled)]]">
        <iron-icon icon="[[stepDownIcon]]"></iron-icon>
      </paper-button>

      <slot name="prefix" slot="prefix"></slot>
      <slot name="suffix" slot="suffix"></slot>

      <paper-button
          tabindex="-1"
          class="spinner"
          slot="suffix"
          suffix
          on-tap="stepUp"
          disabled="[[_computeStepUpButtonDisabled(value, _max, disabled)]]">
        <iron-icon icon="[[stepUpIcon]]"></iron-icon>
      </paper-button>

    </paper-input>

  </template>
  <script>

    Polymer({

      is: 'paper-relative-integer-input',

      properties: {
        /**
        * The tabindex for this input.
        */
        tabIndex: {
          type: Number
        },
        /**
         * The label for this input.
         */
        label: {
          type: String
        },
        /**
         * The number that represents the current value.
         */
        value: {
          type: Number,
          notify: true
        },
        /**
         * Set to true to disable this input.
         */
        disabled: {
          type: Boolean,
          value: false
        },
        /**
         * Returns true if the value is invalid.
         *
         * If `autoValidate` is true, the `invalid` attribute is managed automatically,
         * which can clobber attempts to manage it manually.
         */
        invalid: {
          type: Boolean,
          value: false,
          notify: true
        },
        /**
         * Set to true to mark the input as required.
         */
        required: {
          type: Boolean,
          value: false
        },
        /**
         * The error message to display when the input is invalid.
         */
        errorMessage: {
          type: String
        },
        /**
         * Set to true to disable the floating label.
         */
        noLabelFloat: {
          type: Boolean
        },
        /**
         * Set to true to always float the label.
         */
        alwaysLabelFloat: {
          type: Boolean
        },
        /**
         * Set to true to auto-validate the input value.
         */
        autoValidate: {
          type: Boolean,
          value: false
        },
        /**
         * Name of the validator to use.
         */
        validator: {
          type: String
        },
        /**
         */
        autofocus: {
          type: Boolean
        },
        /**
         * The number that indicates the minimum value. It is used to compute
         * `_min`. If `min` is not a relative integer, `_min` falls back
         * to 0.
         */
        min: {
          type: Number
        },
        /**
        * The number that indicates the maximum value. It is used to compute
        * `_max`. If `max` is not a number, `_max` falls back
        * to Number.POSITIVE_INFINITY. If `max` is inferior to `_min`, `_max`
        * falls back to `_min`.
         */
        max: {
          type: Number
        },
        /**
         * The number that indicates the value increment granularity for
         * stepUp and stepDown actions. It is used to compute `_step`.
         * If `step` is not a number, `_step` falls back to 0.
         */
        step: {
          type: Number,
          value: 1,
          notify: true
        },
        /**
         * The name of this element.
         */
        name: {
          type: String
        },
        /**
         * A placeholder string in addition to the label. If this is set, the label will always float.
         */
        placeholder: {
          type: String
        },
        /**
         * If true, the value can't change due to user input.
         */
        readonly: {
          type: Boolean,
          value: false
        },
        /**
         *
         */
        _ariaDescribedBy: {
          type: String
        },
        /**
         *
         */
        _ariaLabelledBy: {
          type: String
        },
        /**
        * The minimum value the input have.
        * Equals to `min` or 0 if `min` is not a number.
        */
        _min: {
          type: Number,
          computed: '_compute_min(min)',
          readOnly: true,
          value: 0
        },
        /**
         * The maximum value the input have.
         * Equals to `max` or Number.POSITIVE_INFINITY if `max` is not a number.
         */
        _max: {
          type: Number,
          computed: '_compute_max(max, _min)',
          readOnly: true,
          value: Number.POSITIVE_INFINITY
        },
        /**
         * The value increment granularity for stepUp and stepDown actions
         * Equals to `step` or 0 if `step` is not a number.
         */
        _step: {
          type: Number,
          computed: '_compute_sted(step)',
          readOnly: true,
          notify: true
        },
        /**
         * Default fallback when value is not a number.
         */
        fallbackValue: {
          type: Number,
          value: null
        },
        /**
         * The icon key for the step down button. You will need to import an
         * icon set for the icon to appear.
         */
        stepDownIcon: {
          type: String,
          value: 'remove'
        },
        /**
        * The icon key for the step up button. You will need to import an
        * icon set for the icon to appear.
        */
        stepUpIcon: {
          type: String,
          value: 'add'
        },
      },

      observers: [
        '_rangeValue(value, fallbackValue, _min, _max)'
      ],

      _compute_sted: function(step) {
        step = parseInt(step);
        return isNaN(step) ? 0 : step;
      },

      _compute_min: function(min) {
        min = parseInt(min);
        return isNaN(min) || min < 0 ? 0 : min;
      },

      _compute_max: function(max, _min) {
        max = parseInt(max);
        return isNaN(max) ?
          Number.POSITIVE_INFINITY :
          ( max < _min ? _min : max);
      },

      _rangeValue: function(value, fallbackValue, _min, _max) {
        this.value = isNaN((value = this.toRange(value))) ?
          this.toRange(fallbackValue) :
          value;
      },

      /**
       * Rectrict the given value between `_min` and `_max`.
       * @param  {Number} value The value to restrict
       * @return {Number}       The ranged value or NaN if the input value is
       *                        not a number.
       */
      toRange: function(value) {
        return Math.max(this._min, Math.min(parseInt(value), this._max));
      },

      toRangeMax: function(value) {
        return Math.min(this._max, parseInt(value));
      },

      toRangeMin: function(value) {
        return Math.max(this._min, parseInt(value));
      },

      /**
       *
       */
      stepUp: function() {
        this.value = isNaN(this.value) ?
          this.toRange(this._step) :
          this.toRangeMax(this.value + this._step);
      },

      /**
       *
       */
      stepDown: function() {
        this.value = isNaN(this.value) ?
          this.toRange(-this._step) :
          this.toRangeMin(this.value - this._step);
      },

      add: function(n) {
        if (isNaN(n)) n = 0;
        this.value = isNaN(this.value) ?
          this.toRange(n) :
          this.toRange(this.value + n);
      },

      _computeStepDownButtonDisabled: function(value, _min, disabled) {
        return disabled || value <= _min;
      },

      _computeStepUpButtonDisabled: function(value, _max, disabled) {
        return disabled || value >= _max;
      }

    });

  </script>
</dom-module>
